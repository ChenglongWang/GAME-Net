"""This script is used to run GAME-Net on the web server."""

import argparse
import os
import sys
import time
sys.path.insert(0, "../src")
sys.path.insert(0, "./adsurf")
import subprocess as sb
import shutil

import pubchempy as pcp
from ase.io import read, write
from ase.db import connect
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from pymatgen.io.ase import AseAtomsAdaptor

from adsurf.graphs.graph_utilities import ase_2_graph
from adsurf.functions.act_sites import get_act_sites
from adsurf.functions.adsurf_fn import connectivity_analysis, gen_docksurf_file, bottom_poscar
from gnn_eads.nets import PreTrainedModel
from gnn_eads.graph_tools import extract_adsorbate, plotter
from gnn_eads.functions import structure_to_graph

PRG_FULL = "▰"
PRG_EMT = "▱"
TOT_ICN = 20


# Load pre-trained GNN model on CPU
MODEL_PATH = "../models/GAME-Net"
model = PreTrainedModel(MODEL_PATH)


def gnn_predict(poscar_path: str) -> tuple:
    """Provide GAME-Net prediction for a given POSCAR file.

    Parameters
    ----------
    poscar_path : str
        Path to the POSCAR file

    Returns
    -------
    energy_ensemble : float
        Energy of the ensemble adsorption system (eV)
    energy_molecule : float
        Energy of the adsorbate molecule (eV)
    adsorption_energy : float
        Adsorption energy (eV)
    """

    ads_graph = structure_to_graph(
        poscar_path, model.g_tol, model.g_sf, model.g_metal_2nn)
    
    molecule_graph = extract_adsorbate(ads_graph)

    if ads_graph.num_nodes == molecule_graph.num_nodes:
        adsorption_system = False
    else:
        adsorption_system = True

    energy_ensemble = model.evaluate(ads_graph)
    if adsorption_system:
        energy_molecule = model.evaluate(molecule_graph)
        adsorption_energy = energy_ensemble - energy_molecule
        return (energy_ensemble, energy_molecule, adsorption_energy, adsorption_system)
    else:
        return (energy_ensemble, energy_ensemble, None, adsorption_system)


def walk_through_poscars(dos_path: str) -> dict:
    """Walk through the output directory generated by DockonSurf and provide the path to each POSCAR file.

    Parameters
    ----------
    run_path : str
        Path to the run directory
    
    Returns
    -------
    poscar_dict : dict
        Dictionary of POSCAR files paths
    """
    poscar_dict = {}
    counter = 0
    for root, dirs, files in os.walk(dos_path):
        for sub_dirs in dirs:
            try:
                for sub_dirs_2 in os.listdir(os.path.join(root, sub_dirs)):
                    sub_path = os.path.join(root, sub_dirs, sub_dirs_2)
                    try:
                        for files in os.listdir(sub_path):
                            if files == 'POSCAR':
                                counter += 1
                                poscar_path = os.path.join(sub_path, files)
                                poscar_dict[str(counter)] = poscar_path
                    except NotADirectoryError:
                        continue
            except NotADirectoryError:
                continue
    print("Total number of potential adsorption configurations: ", counter)
    return poscar_dict

def metal_structure(metal: str) -> str:
    """Return the structure of the metal.

    Parameters
    ----------
    metal : str
        Name of the metal

    Returns
    -------
    structure : str
        Structure of the metal
    """
    if metal.capitalize() in ("Ag", "Au", "Cu", "Ir", "Ni", "Pd", "Pt", "Rh"):
        return "fcc"
    elif metal.capitalize() in ("Cd", "Co", "Os", "Ru", "Zn"):
        return "hcp"
    elif metal.capitalize() in ("Fe"):
        return "bcc"
    else:
        return "Unknown"

def gen_dockonsurf_input(molecule: str,
                         metal: str,
                         surface_facet: str,
                         OUTPUT_DIR: str,
                         molecule_format: str = 'name',
                         ads_height: float = 2.5,
                         ) -> tuple:
    """Collect the inputs for the generation of adsorption configurations.

    Parameters
    ----------
    molecule : str
        name of the molecule
    metal : str
        name of the metal
    surface_facet : str
        name of the surface facet
    molecule_format : str, optional
        Name of the molecule format, by default 'name'.
        Other options are 'smiles', 'inchi', 'inchikey', 'sdf', 'formula'.
        NB: 'name' refers to the IUPAC name of the molecule.
    calc_type : str, optional
        Type of calculation, by default 'adsorption'
    ads_height : float, optional
        Adsorption height (in Angstrom) used by DockonSurf to screen potential configurations, by default 2.5

    Returns
    -------
    tmp_subdir : str
        Path to the directory containing the results of the run
    iupac_name : str
        IUPAC name of the molecule
    canonical_smiles : str
        Canonical SMILES of the molecule   
    """
    # Retrieve the molecule from PubChem
    pubchem_molecule = pcp.get_compounds(
        molecule, molecule_format, record_type='3d', listkey_count=1)[0]    
    pubchem_cid = pubchem_molecule.cid
    c = pcp.Compound.from_cid(pubchem_cid)
    iupac_name = c.iupac_name
    canonical_smiles = c.canonical_smiles
    
    # Create output directory for the studied adsorption system
    iupac_file_name = iupac_name.replace(' ', '_').replace('(', '_').replace(')', '_').replace("'", "")
    tmp_subdir = os.path.join(
        OUTPUT_DIR, f"{iupac_file_name}_{metal}{surface_facet.replace('(', '_').replace(')', '').replace(' ', '')}")
    os.makedirs(tmp_subdir, exist_ok=True)
    
    # Write the molecule in xyz format
    pubchem_atoms = pubchem_molecule.atoms
    n_atoms = len(pubchem_atoms)
    molecule_xyz_file = os.path.join(tmp_subdir, iupac_file_name + ".xyz")
    with open(molecule_xyz_file, "w") as f:
        f.write(f"{n_atoms}\n\n")
        for atom in pubchem_atoms:
            f.write(f"{atom.element}\t{atom.x} {atom.y} {atom.z}\n")

    # Convert xyz file to ASE object and get the distance between the furthest atoms
    molec_ase_obj = read(molecule_xyz_file)
    molec_dist_mat = molec_ase_obj.get_all_distances(mic=True)
    max_dist_molec = np.max(molec_dist_mat)
    print('Distance between furthest atoms in the molecule: {:.2f} Angstrom'.format(max_dist_molec))

    # Convert ASE object to graph and get potential molecular centers for adsorption
    molec_graph = ase_2_graph(molec_ase_obj, coords=True)
    connect_sites_molec = connectivity_analysis(molec_graph)

    # Get metal slab from ASE database, given metal and surface facet
    surf_db_path = './adsurf/data/metal_surfaces.db'
    surf_db = connect(surf_db_path)
    slab_poscar_file = os.path.join(tmp_subdir, "POSCAR")
    metal_struct = metal_structure(metal)
    full_facet = f"{metal_struct}({surface_facet})"
    slab_ase_obj = surf_db.get_atoms(metal=metal, facet=full_facet)
    a, b, _ = slab_ase_obj.get_cell()
    slab_diagonal = np.sqrt(np.linalg.norm(a)**2 + np.linalg.norm(b)**2)
    print('Surface x-y extension: {:.2f} Angstrom'.format(slab_diagonal))

    # Check if molecule fits on reference metal slab, if not scale the surface
    tolerance = 10.0   # Angstrom
    condition = slab_diagonal - tolerance > max_dist_molec
    if condition:
        print('Molecule fits on reference metal slab\n')
    else:
        print('Scaling reference metal slab...')
        counter = 1
        while not condition:
            counter += 1
            pymatgen_slab = AseAtomsAdaptor.get_structure(slab_ase_obj)
            pymatgen_slab.make_supercell([counter, counter, 1])
            slab_ase_obj = AseAtomsAdaptor.get_atoms(pymatgen_slab)
            a, b, _ = slab_ase_obj.get_cell()
            slab_diagonal = np.sqrt(np.linalg.norm(a*counter)**2 + np.linalg.norm(b*counter)**2)
            condition = slab_diagonal - tolerance > max_dist_molec
        print('Reference metal slab scaled by factor {} on the x-y plane\n'.format(counter)) 
    
    # Write the slab in POSCAR format for DockonSurf
    write(slab_poscar_file, slab_ase_obj, format='vasp')

    # Generate input files for DockonSurf
    slab_active_sites = get_act_sites(slab_poscar_file)
    slab_lattice = slab_ase_obj.get_cell().lengths()
    for active_site, site_idxs in slab_active_sites.items():
        if site_idxs != []:
            gen_docksurf_file(tmp_subdir, 
                              iupac_file_name, 
                              molec_ase_obj, 
                              connect_sites_molec, 
                              slab_poscar_file, 
                              slab_lattice, 
                              active_site, 
                              site_idxs, 
                              ads_height)
    
    # Run DockonSurf
    init_path = os.getcwd()
    dockonsurf_path = os.path.join(init_path, 'dockonsurf', 'dockonsurf.py')
    for root, _, files in os.walk(tmp_subdir):
        for file in files:
            if file.endswith(".inp"):
                os.chdir(root)
                sb.call(["python", dockonsurf_path, "-i", file])
                os.chdir(init_path)
    time.sleep(5)  # Wait for DockonSurf (5 seconds) to finish before proceeding
    bottom_poscar(2, tmp_subdir)  
    return tmp_subdir, iupac_name, canonical_smiles

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Provide GAME-Net prediction for potential adsorption configurations on a metal surface for a specific molecule')
    parser.add_argument('-id_format', type=str, dest="id_format", default='iupac', 
                        help='format of the molecule identifier (options: name, smiles, inchi, inchikey, sdf, formula)')
    parser.add_argument('-id', '--identifier', type=str, dest="id",
                        help='identifier of the molecule')
    parser.add_argument('-m', '--metal', type=str, dest="metal",
                        help='symbol of the metal (e.g. Au)')
    parser.add_argument('-sf', '--surface_facet', type=str, dest="surface_facet",
                        help='surface facet (e.g. 111)')
    parser.add_argument('-ads_height', type=float, dest="ads_height", default=2.5,
                        help='adsorption height used in DockonSurf to screen potential configurations')
    args = parser.parse_args()

    # Load pre-trained GNN model on CPU
    MODEL_PATH = "../models/GAME-Net"
    model = PreTrainedModel(MODEL_PATH)
    print("Pre-trained GAME-Net model loaded\n")


    OUTPUT_DIR = './results'
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    tmp_subdir, iupac_name, canonical_smiles = gen_dockonsurf_input(args.id, 
                                                                    args.metal, 
                                                                    args.surface_facet, 
                                                                    OUTPUT_DIR, 
                                                                    ads_height = args.ads_height, 
                                                                    molecule_format=args.id_format)
    poscar_dict = walk_through_poscars(tmp_subdir)
    if len(poscar_dict) == 0:
        print('No adsorption configurations found for the given molecule. Try to increase the adsorption height (default 2.5 Angstrom)')
        exit(0)
    energy_ensemble, energy_molecule, adsorption_energy, poscar_list, counter_list = [], [], [], [], []
    counter = 0
    print("Screening adsorption configurations ...")

    for idx, poscar_path in enumerate(poscar_dict.values()):
        prc = int((idx+1)/len(poscar_dict.values())*TOT_ICN)
        ensemble, molecule, adsorption, adsorption_bool = gnn_predict(poscar_path)
        energy_ensemble.append(ensemble)
        energy_molecule.append(molecule)
        adsorption_energy.append(adsorption)
        poscar_list.append(poscar_path)
        counter += 1
        counter_list.append(counter)

        print(f"Progress: {PRG_FULL*prc}{PRG_EMT*(TOT_ICN-prc)} ({prc*100/TOT_ICN}%)", end="\r")

    df = pd.DataFrame({'counter': counter_list, 'poscar': poscar_list, 'ensemble': energy_ensemble,
                          'molecule': energy_molecule, 'adsorption': adsorption_energy})
    df = df[df['adsorption'] != None]
    df.to_csv(os.path.join(tmp_subdir, 'prediction.csv'))

    # Delete temporary generated files by DockonSurf
    for root, dirs, files in os.walk(tmp_subdir):
        if dirs == 'poscar_dockonsurf':
            shutil.rmtree(os.path.join(root, dirs))
        for file in files:
            if file == 'INCAR' or file == 'KPOINTS':
                os.remove(os.path.join(root, file))
            
    
    # Remove all files with .xyz extension
    for root, dirs, files in os.walk(tmp_subdir):
        for file in files:
            if file.endswith(".xyz"):
                os.remove(os.path.join(root, file))
    os.remove(os.path.join(tmp_subdir, 'POSCAR'))

    metal_surface = args.metal + '(' + args.surface_facet + ')'
    ener_most_stable_conf = df['adsorption'].min()
    ensemble_most_stable_conf = df[df['adsorption'] == df['adsorption'].min()]['ensemble'].values[0]
    molecule_most_stable_conf = df[df['adsorption'] == df['adsorption'].min()]['molecule'].values[0]
    most_stable_conf_path = df[df['adsorption'] == df['adsorption'].min()]['poscar'].values[0]
    system_title = iupac_name + ' on ' + metal_surface
    print('\n\nSystem: ', system_title) 
    print('Canonical SMILES: ', canonical_smiles)
    print('Metal surface: {}'.format(metal_surface))
    print('Number of detected adsorption configurations: ', len(df))
    print('Adsorption energy (most stable configuration): {:.2f} eV'.format(ener_most_stable_conf))
    print('Path to most stable configuration: ', most_stable_conf_path)
    
    ads_graph = structure_to_graph(
        most_stable_conf_path, model.g_tol, model.g_sf, model.g_metal_2nn)
    plotter(ads_graph, dpi=300)
    plt.savefig(os.path.join(tmp_subdir,"most_stable_ads_graph.png"))