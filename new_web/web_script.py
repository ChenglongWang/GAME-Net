from ase.io import read, write
from ase.db import connect
import pubchempy as pcp
import pprint as pp
import argparse
import os
import sys
import time
sys.path.insert(0, "../src")
sys.path.insert(0, "./adsurf")
import subprocess as sb

from gnn_eads.nets import PreTrainedModel
from gnn_eads.graph_tools import extract_adsorbate, plotter
import matplotlib.pyplot as plt
from gnn_eads.functions import structure_to_graph
from graphs.graph_utilities import ase_2_graph
from functions.act_sites import get_act_sites
from functions.adsurf_fn import connectivity_annalysis, gen_docksurf_file, run_dockonsurf, bottom_poscar
import pandas as pd
import numpy as np
import pprint as pp
import shutil
from pymatgen.io.ase import AseAtomsAdaptor



# 1) Load pre-trained GNN model on CPU
MODEL_PATH = "../models/GAME-Net"
model = PreTrainedModel(MODEL_PATH)


def gnn_predict(poscar_path: str):
    """provide GAME-Net prediction for a given poscar file

    Parameters
    ----------
    poscar_path : str
        path to the poscar file
    """

    ads_graph = structure_to_graph(
        poscar_path, model.g_tol, model.g_sf, model.g_metal_2nn)
    
    molecule_graph = extract_adsorbate(ads_graph)

    if ads_graph.num_nodes == molecule_graph.num_nodes:
        adsorption_system = False
    else:
        adsorption_system = True

    energy_ensemble = model.evaluate(ads_graph)
    if adsorption_system:
        energy_molecule = model.evaluate(molecule_graph)
        adsorption_energy = energy_ensemble - energy_molecule
        print("Adsorption energy: {:.2f} eV".format(adsorption_energy))
        return (energy_ensemble, energy_molecule, adsorption_energy)
    else:
        print("Gas phase energy: {:.2f} eV".format(energy_ensemble))
        return (energy_ensemble, energy_ensemble, None)


def walk_through_poscars(dos_path: str):
    """walk through the output directory generated by DockonSurf provide the poscar path for each poscar file

    Parameters
    ----------
    run_path : str
        path to the run directory
    """
    poscar_dict = {}
    counter = 0
    for root, dirs, files in os.walk(dos_path):
        for sub_dirs in dirs:
            try:
                for sub_dirs_2 in os.listdir(os.path.join(root, sub_dirs)):
                    sub_path = os.path.join(root, sub_dirs, sub_dirs_2)
                    try:
                        for files in os.listdir(sub_path):
                            if files == 'POSCAR':
                                counter += 1
                                poscar_path = os.path.join(sub_path, files)
                                poscar_dict[str(counter)] = poscar_path
                    except NotADirectoryError:
                        continue
            except NotADirectoryError:
                continue
    print("Total number of potential adsorption configurations: ", counter)
    return poscar_dict

def metal_structure(metal: str):
    if metal.capitalize() in ("Ag", "Au", "Cu", "Ir", "Ni", "Pd", "Pt", "Rh"):
        return "fcc"
    elif metal.capitalize() in ("Cd", "Co", "Os", "Ru", "Zn"):
        return "hcp"
    elif metal.capitalize() in ("Fe"):
        return "bcc"
    else:
        return "Unknown"

def gen_dockonsurf_input(molecule: str,
                         metal: str,
                         surface_facet: str,
                         output_dir: str,
                         molecule_format: str = 'name',
                         ads_height: float = 2.5,
                         ):
    """collect the input for the prediction


    Parameters
    ----------
    molecule : str
        name of the molecule
    metal : str
        name of the metal
    surface_facet : str
        name of the surface facet
    molecule_format : str, optional
        name of the molecule format, by default 'name'.
        Other options are 'smiles', 'inchi', 'inchikey', 'sdf', 'formula'.
    calc_type : str, optional
        type of calculation, by default 'adsorption'
    ads_height : float, optional
        adsorption height used by DockonSurf to screen potential configurations, by default 2.5

    Returns
    -------
    [type]
        [description]
    """
    pubchem_molecule = pcp.get_compounds(
        molecule, molecule_format, record_type='3d', listkey_count=1)[0]
    
    pubchem_cid = pubchem_molecule.cid
    c = pcp.Compound.from_cid(pubchem_cid)
    iupac_name = c.iupac_name
    canonical_smiles = c.canonical_smiles

    iupac_file_name = iupac_name.replace(' ', '_').replace('(', '_').replace(')', '_').replace("'", "")
    # create output directory
    tmp_subdir = os.path.join(
        output_dir, f"{iupac_file_name}_{metal}{surface_facet.replace('(', '_').replace(')', '').replace(' ', '')}")
    os.makedirs(tmp_subdir, exist_ok=True)
    # get molecule xyz from molecule identifier and format with pubchempy
    
    pubchem_atoms = pubchem_molecule.atoms
    n_atoms = len(pubchem_atoms)
    molecule_xyz_file = os.path.join(tmp_subdir, iupac_file_name + ".xyz")

    with open(molecule_xyz_file, "w") as f:
        f.write(f"{n_atoms}\n\n")
        for atom in pubchem_atoms:
            f.write(f"{atom.element}\t{atom.x} {atom.y} {atom.z}\n")

    molec_ase_obj = read(molecule_xyz_file)
    # get distance matrix of molecule
    molec_dist_mat = molec_ase_obj.get_all_distances(mic=True)
    max_dist_molec = np.max(molec_dist_mat)
    print('Distance between furthest atoms in the molecule (Angstrom): ',max_dist_molec)
    molec_graph = ase_2_graph(molec_ase_obj, coords=True)
    connect_sites_molec = connectivity_annalysis(molec_graph)

    # get CONTCAR of slab from ASE database, given metal and surface facet
    surf_db_path = './adsurf/data/metal_surfaces.db'
    surf_db = connect(surf_db_path)

    slab_poscar_file = os.path.join(tmp_subdir, "POSCAR")
    
    metal_struct = metal_structure(metal)
    full_facet = f"{metal_struct}({surface_facet})"
    slab_ase_obj = surf_db.get_atoms(metal=metal, facet=full_facet)
    a, b, _ = slab_ase_obj.get_cell()

    slab_diagonal = np.sqrt(np.linalg.norm(a)**2 + np.linalg.norm(b)**2)
    print('Cell x-y extension (Angstrom): ', slab_diagonal)
    
    tolerance = 10.0   # Angstrom

    condition = slab_diagonal - tolerance > max_dist_molec
    if condition:
        print('Molecule fits on reference metal slab\n')
    else:
        print('Scaling reference metal slab...')
        counter = 1
        while not condition:
            counter += 1
            pymatgen_slab = AseAtomsAdaptor.get_structure(slab_ase_obj)
            pymatgen_slab.make_supercell([counter, counter, 1])
            slab_ase_obj = AseAtomsAdaptor.get_atoms(pymatgen_slab)
            a, b, _ = slab_ase_obj.get_cell()
            # slab_ase_obj.set_cell([a*counter, b*counter, _], scale_atoms=False)
            slab_diagonal = np.sqrt(np.linalg.norm(a*counter)**2 + np.linalg.norm(b*counter)**2)
            condition = slab_diagonal - tolerance > max_dist_molec
        print('Reference metal slab scaled by factor {} on the x-y plane\n'.format(counter)) 
    write(slab_poscar_file, slab_ase_obj, format='vasp')

    slab_active_sites = get_act_sites(slab_poscar_file)
    slab_lattice = slab_ase_obj.get_cell().lengths()

    # generate input files for DockonSurf
    for active_site, site_idxs in slab_active_sites.items():
        if site_idxs != []:
            gen_docksurf_file(tmp_subdir, iupac_file_name, molec_ase_obj, connect_sites_molec,slab_poscar_file, slab_lattice, active_site, site_idxs, ads_height)
    
    # run DockonSurf
    init_path = os.getcwd()
    dockonsurf_path = os.path.join(init_path, 'dockonsurf', 'dockonsurf.py')
    for root, _, files in os.walk(tmp_subdir):
        for file in files:
            if file.endswith(".inp"):
                os.chdir(root)
                sb.call(["python", dockonsurf_path, "-i", file])
                os.chdir(init_path)
    # run_dockonsurf(tmp_subdir)
    time.sleep(5)
    bottom_poscar(2, tmp_subdir)
    return tmp_subdir, iupac_name, canonical_smiles

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description='Provide GAME-Net prediction for a given poscar file')
    parser.add_argument('-id_format', type=str, dest="id_format", default='iupac', 
                        help='format of the molecule identifier (e.g. iupac, smiles, inchi, inchikey, sdf, formula)')
    parser.add_argument('-id', '--identifier', type=str, dest="id",
                        help='identifier of the molecule')
    parser.add_argument('-m', '--metal', type=str, dest="metal",
                        help='symbol of the metal (e.g. Au)')
    parser.add_argument('-sf', '--surface_facet', type=str, dest="surface_facet",
                        help='surface facet (e.g. 111)')
    parser.add_argument('-ads_height', type=float, dest="ads_height", default=2.5,
                        help='adsorption height used in DockonSurf to screen potential configurations')
    # parser.add_argument('-o', '--output_dir', type=str, dest="output_dir",
    #                     help='name of the directory where the output files will be stored (ex. methane_Au_111)')
    args = parser.parse_args()

    output_dir = './results'
    os.makedirs(output_dir, exist_ok=True)
    tmp_subdir, iupac_name, canonical_smiles = gen_dockonsurf_input(args.id, args.metal, args.surface_facet, output_dir, ads_height = args.ads_height, molecule_format=args.id_format)
    poscar_dict = walk_through_poscars(tmp_subdir)
    if len(poscar_dict) == 0:
        print('No adsorption configurations found for the given molecule. Try to increase the adsorption height (default 2.5 Angstrom)')
        exit(0)
    print('POSCAR Dictionary:')
    pp.pprint(poscar_dict)
    energy_ensemble, energy_molecule, adsorption_energy, poscar_list, counter_list = [], [], [], [], []
    counter = 0
    for poscar_path in poscar_dict.values():
        ensemble, molecule, adsorption = gnn_predict(poscar_path)
        energy_ensemble.append(ensemble)
        energy_molecule.append(molecule)
        adsorption_energy.append(adsorption)
        poscar_list.append(poscar_path)
        counter += 1
        counter_list.append(counter)
        print("{}) Adsorption energy (eV): ".format(counter), adsorption)
    df = pd.DataFrame({'counter': counter_list, 'poscar': poscar_list, 'ensemble': energy_ensemble,
                          'molecule': energy_molecule, 'adsorption': adsorption_energy})
    df = df[df['adsorption'] != None]
    df.to_csv(os.path.join(tmp_subdir, 'prediction.csv'))

    # Delete temporary generated files by DockonSurf
    for root, dirs, files in os.walk(tmp_subdir):
        if dirs == 'poscar_dockonsurf':
            shutil.rmtree(os.path.join(root, dirs))
        for file in files:
            if file == 'INCAR' or file == 'KPOINTS':
                os.remove(os.path.join(root, file))
            
    
    # Remove all files with .xyz extension
    for root, dirs, files in os.walk(tmp_subdir):
        for file in files:
            if file.endswith(".xyz"):
                os.remove(os.path.join(root, file))
    os.remove(os.path.join(tmp_subdir, 'POSCAR'))

    print('\nSystem: ', args.id) 
    print('IUPAC name: ', iupac_name)
    print('Canonical SMILES: ', canonical_smiles)
    print(f'Metal Surface: {args.metal}({args.surface_facet})')
    print('Number of detected adsorption configurations: ', len(df))
    print('Adsorption energy (most stable configuration, eV): ', df['adsorption'].min())
    most_stable_conf_path = df[df['adsorption'] == df['adsorption'].min()]['poscar'].values[0]
    print('Path to most stable configuration: ', most_stable_conf_path)
    
    ads_graph = structure_to_graph(
        most_stable_conf_path, model.g_tol, model.g_sf, model.g_metal_2nn)
    plotter(ads_graph, dpi=300)
    plt.savefig(os.path.join(tmp_subdir,"most_stable_ads_graph.png"))